<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Services - SimpleWatch</title>
    <link rel="stylesheet" href="/static/css/theme.css">
    <style>
        .main-container { max-width: 1400px; margin: 0 auto; padding: 3rem 2rem; }
        .page-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3rem; }
        .page-title { font-size: 2.5rem; font-weight: 700; background: linear-gradient(135deg, var(--text-primary), var(--text-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .action-buttons { display: flex; gap: 1rem; }

        /* Service cards */
        .service-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 1rem; padding: 1.5rem; margin-bottom: 1.5rem; transition: all var(--transition-normal); }
        .service-card:hover { border-color: var(--border-hover); box-shadow: var(--shadow-md); }
        .service-header { display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem; }
        .service-title { font-size: 1.5rem; font-weight: 700; color: var(--text-primary); }
        .service-actions { display: flex; gap: 0.5rem; }
        .service-description { color: var(--text-secondary); margin-bottom: 1rem; }
        .service-meta { display: flex; gap: 2rem; margin-bottom: 1rem; font-size: 0.875rem; color: var(--text-tertiary); }

        /* Monitor list */
        .monitors-section { border-top: 1px solid var(--border-color); padding-top: 1rem; }
        .monitors-title { font-weight: 700; color: var(--text-secondary); text-transform: uppercase; font-size: 0.875rem; letter-spacing: 0.05em; margin-bottom: 1rem; }
        .monitor-item { background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 0.75rem; padding: 1rem; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; transition: all var(--transition-normal); }
        .monitor-item:hover { border-color: var(--border-hover); box-shadow: var(--shadow-sm); }
        .monitor-info { flex: 1; }
        .monitor-type { font-weight: 700; color: var(--text-primary); margin-bottom: 0.25rem; }
        .monitor-config { font-size: 0.875rem; color: var(--text-secondary); font-family: var(--font-mono); word-break: break-all; }
        .monitor-interval { font-size: 0.75rem; color: var(--text-tertiary); text-transform: uppercase; }
        .monitor-actions { display: flex; gap: 0.5rem; }

        /* Form styling */
        .form-group { margin-bottom: 1.5rem; }
        .form-label { display: block; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.875rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; }
        .form-input { width: 100%; padding: 0.75rem 1rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 0.5rem; color: var(--text-primary); transition: all var(--transition-normal); }
        .form-input:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px var(--accent-glow); }
        .form-hint { font-size: 0.75rem; color: var(--text-tertiary); margin-top: 0.25rem; }

        /* Modal specific styles */
        .modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; z-index: 1000; animation: fadeIn var(--transition-normal); }
        .modal-content { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 1.5rem; padding: 2rem; max-width: 600px; width: 90%; max-height: 90vh; overflow: hidden auto; box-shadow: var(--shadow-lg); animation: scaleIn var(--transition-normal); position: relative; }
        .modal-content.large { max-width: 800px; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid var(--border-color); }
        .modal-title { font-size: 1.5rem; font-weight: 700; }
        .modal-subtitle { color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.25rem; }

        /* Monitor type selection */
        .type-grid { display: grid; gap: 1rem; margin-bottom: 1.5rem; }
        .type-card { padding: 1.25rem; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: 0.75rem; cursor: pointer; transition: all var(--transition-normal); }
        .type-card:hover { border-color: var(--accent-primary); box-shadow: var(--shadow-glow); transform: translateY(-2px); }
        .type-card-title { font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
        .type-card-desc { font-size: 0.875rem; color: var(--text-secondary); }

        .monitor-type-badge { display: inline-flex; align-items: center; gap: 0.375rem; padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border-radius: 0.375rem; font-size: 0.8125rem; font-weight: 600; color: var(--text-secondary); }
        .monitor-type-badge .icon { opacity: 0.7; }

        /* Checkbox styling */
        input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            cursor: pointer;
            flex-shrink: 0;
        }

        /* Collapsible sections */
        .collapsible {
            margin: 1rem 0;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }

        .collapsible-trigger {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 600;
            transition: all var(--transition-fast);
        }

        .collapsible-trigger:hover {
            background: var(--bg-secondary);
        }

        .collapsible-icon {
            width: 1rem;
            height: 1rem;
            transition: transform var(--transition-fast);
            flex-shrink: 0;
        }

        .collapsible-trigger[aria-expanded="true"] .collapsible-icon {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: var(--bg-primary);
            width: 100%;
            box-sizing: border-box;
        }

        .collapsible-content.expanded {
            max-height: 1000px;
        }

        .collapsible-content-inner {
            padding: 1rem;
        }

        .code-example {
            margin-top: 0;
            width: 100%;
            box-sizing: border-box;
        }

        .code-block {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            padding: 1rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-secondary);
            overflow-x: auto;
            line-height: 1.5;
            white-space: pre-wrap;
            width: 100%;
            box-sizing: border-box;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="navigation" data-page="services"></div>

    <div class="main-container">
        <div class="page-header">
            <div>
                <h1 class="page-title">Services & Monitors</h1>
                <p style="color: var(--text-secondary); margin-top: 0.5rem;">Manage your monitoring services and checks</p>
            </div>
            <div class="action-buttons">
                <button onclick="showAddServiceModal()" class="btn btn-secondary">+ Add Service</button>
                <button onclick="showQuickMonitorModal()" class="btn btn-primary">‚ö° Quick Monitor</button>
            </div>
        </div>

        <div id="servicesList"></div>
    </div>

    <!-- Add Service Modal -->
    <div id="addServiceModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Add Service</h3>
            </div>
            <form id="addServiceForm">
                <div class="form-group">
                    <label class="form-label">Service Name</label>
                    <input type="text" id="serviceName" class="form-input" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea id="serviceDescription" class="form-input" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Category</label>
                    <input type="text" id="serviceCategory" class="form-input">
                </div>
                <div style="display: flex; gap: 1rem;">
                    <button type="submit" class="btn btn-primary" style="flex: 1;">Create</button>
                    <button type="button" onclick="hideAddServiceModal()" class="btn btn-secondary" style="flex: 1;">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Service Modal -->
    <div id="editServiceModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Edit Service</h3>
            </div>
            <form id="editServiceForm">
                <input type="hidden" id="editServiceId">
                <div class="form-group">
                    <label class="form-label">Service Name</label>
                    <input type="text" id="editServiceName" class="form-input" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea id="editServiceDescription" class="form-input" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Category</label>
                    <input type="text" id="editServiceCategory" class="form-input">
                </div>

                <!-- Notification Settings Section -->
                <div style="border-top: 1px solid var(--border-color); margin-top: 2rem; padding-top: 2rem;">
                    <h4 style="font-weight: 700; margin-bottom: 1rem; color: var(--text-primary); display: flex; align-items: center; gap: 0.5rem;">
                        <span class="icon icon-lg" style="color: var(--accent-primary);" innerHTML="${icons.bell}"></span>
                        Notification Settings
                    </h4>

                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="editNotificationsEnabled" class="form-checkbox" checked>
                            <span>Enable notifications for this service</span>
                        </label>
                    </div>

                    <div id="notificationSettingsContent">
                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="editEmailEnabled" class="form-checkbox">
                                <span>Send email notifications</span>
                            </label>
                        </div>

                        <div class="form-group" id="emailRecipientsGroup" style="display: none;">
                            <label class="form-label">Email Recipients (comma-separated)</label>
                            <input type="text" id="editEmailRecipients" class="form-input" placeholder="admin@example.com, ops@example.com">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Webhook Channels</label>
                            <div id="webhookChannelsList" style="font-size: 0.875rem; color: var(--text-secondary);">
                                Loading channels...
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Cooldown Period (minutes)</label>
                            <input type="number" id="editCooldownMinutes" class="form-input" value="5" min="1">
                            <div style="font-size: 0.75rem; color: var(--text-tertiary); margin-top: 0.5rem;">
                                Minimum time between notifications to prevent spam
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="editNotifyOnRecovery" class="form-checkbox" checked>
                                <span>Send recovery notifications</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 1rem;">
                    <button type="submit" class="btn btn-primary" style="flex: 1;">Update</button>
                    <button type="button" onclick="hideEditServiceModal()" class="btn btn-secondary" style="flex: 1;">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Quick Monitor Modal -->
    <div id="quickMonitorModal" class="modal hidden">
        <div class="modal-content large">
            <div class="modal-header">
                <div>
                    <h3 class="modal-title">Quick Monitor Setup</h3>
                    <p class="modal-subtitle">Create a service and monitor in one step</p>
                </div>
            </div>

            <!-- Type Selection Screen -->
            <div id="monitorTypeSelection">
                <h4 style="font-weight: 700; margin-bottom: 1rem; color: var(--text-primary);">Select Monitor Type</h4>
                <div id="quickMonitorTypeGrid" class="type-grid">
                    <!-- Cards will be injected here by registry -->
                </div>
                <button onclick="hideQuickMonitorModal()" class="btn btn-secondary" style="width: 100%;">Cancel</button>
            </div>

            <!-- Monitor Configuration Form (dynamically generated) -->
            <div id="monitorConfigForm" class="hidden">
                <button onclick="backToMonitorSelection()" class="btn btn-secondary" style="margin-bottom: 1rem;">‚Üê Back</button>
                <h4 id="monitorFormTitle" style="font-weight: 700; margin-bottom: 1rem;"></h4>
                <form id="quickMonitorForm" onsubmit="handleQuickMonitorSubmit(event)">
                    <div id="quickMonitorFormFields">
                        <!-- Fields will be injected here -->
                    </div>
                    <button type="submit" class="btn btn-primary" style="width: 100%;">Create Monitor</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Monitor to Service Modal -->
    <div id="addMonitorToServiceModal" class="modal hidden">
        <div class="modal-content large">
            <div class="modal-header">
                <div>
                    <h3 class="modal-title">Add Monitor to Service</h3>
                    <p class="modal-subtitle">Service: <span id="targetServiceName"></span></p>
                </div>
            </div>
            <input type="hidden" id="targetServiceId">

            <!-- Type Selection Screen -->
            <div id="addMonitorTypeSelection">
                <h4 style="font-weight: 700; margin-bottom: 1rem; color: var(--text-primary);">Select Monitor Type</h4>
                <div id="addMonitorTypeGrid" class="type-grid">
                    <!-- Cards will be injected here by registry -->
                </div>
                <button onclick="hideAddMonitorToServiceModal()" class="btn btn-secondary" style="width: 100%; margin-top: 1rem;">Cancel</button>
            </div>

            <!-- Monitor Configuration Form (dynamically generated) -->
            <div id="addMonitorConfigForm" class="hidden">
                <button onclick="backToAddMonitorSelection()" class="btn btn-secondary" style="margin-bottom: 1rem;">‚Üê Back</button>
                <h4 id="addMonitorFormTitle" style="font-weight: 700; margin-bottom: 1rem;"></h4>
                <form id="addMonitorForm" onsubmit="handleAddMonitorSubmit(event)">
                    <div id="addMonitorFormFields">
                        <!-- Fields will be injected here -->
                    </div>
                    <button type="submit" class="btn btn-primary" style="width: 100%;">Add Monitor</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Edit Monitor Modal (Generic, plugin-based) -->
    <div id="editMonitorModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="editMonitorTitle">Edit Monitor</h3>
            </div>
            <form id="editMonitorForm" onsubmit="handleEditMonitorSubmit(event)">
                <input type="hidden" id="editMonitorId">
                <input type="hidden" id="editMonitorType">
                <input type="hidden" id="editMonitorServiceId">
                <input type="hidden" id="editMonitorServiceName">
                <div id="editMonitorFormFields">
                    <!-- Fields will be injected here by registry -->
                </div>
                <div style="display: flex; gap: 1rem;">
                    <button type="submit" class="btn btn-primary" style="flex: 1;">Update</button>
                    <button type="button" onclick="hideEditMonitorModal()" class="btn btn-secondary" style="flex: 1;">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script src="/static/js/components.js"></script>
    <script src="/static/js/theme.js"></script>
    <script src="/static/js/api.js"></script>
    <script src="/static/js/auth.js"></script>
    <script src="/static/js/nav.js"></script>

    <!-- Monitor Plugin System -->
    <script type="module">
        import monitorRegistry from '/static/js/monitors/registry.js';

        // Store current Quick Monitor type globally
        window.currentQuickMonitorType = null;

        // Make registry available globally
        window.monitorRegistry = monitorRegistry;

        // Initialize plugin system on page load
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Load all monitor plugins
                await monitorRegistry.loadMonitors();
                console.log('Monitor plugins loaded successfully');

                // Render Quick Monitor type cards
                const quickMonitorTypeGrid = document.getElementById('quickMonitorTypeGrid');
                if (quickMonitorTypeGrid) {
                    quickMonitorTypeGrid.innerHTML = monitorRegistry.renderTypeCards('selectMonitorType');
                }

                // Render Add Monitor type cards (if needed later)
                const addMonitorTypeGrid = document.getElementById('addMonitorTypeGrid');
                if (addMonitorTypeGrid) {
                    addMonitorTypeGrid.innerHTML = monitorRegistry.renderTypeCards('selectAddMonitorType');
                }
            } catch (error) {
                console.error('Failed to initialize monitor plugin system:', error);
            }
        });
    </script>

    <script>
        requireAuth();

        const userInfo = getUserInfo();

        // Load services
        async function loadServices() {
            try {
                const services = await api.listServices();
                const monitors = await api.listMonitors();

                // Group monitors by service_id
                const monitorsByService = {};
                monitors.forEach(monitor => {
                    if (!monitorsByService[monitor.service_id]) {
                        monitorsByService[monitor.service_id] = [];
                    }
                    monitorsByService[monitor.service_id].push(monitor);
                });

                const servicesList = document.getElementById('servicesList');

                if (services.length === 0) {
                    servicesList.innerHTML = '<div style="text-align: center; padding: 4rem; color: var(--text-secondary);"><h3 style="font-size: 1.5rem; margin-bottom: 1rem;">No services yet</h3><p>Create your first service using Quick Monitor or Add Service</p></div>';
                    return;
                }

                servicesList.innerHTML = services.map(service => {
                    const serviceMonitors = monitorsByService[service.id] || [];
                    return `
                    <div class="service-card">
                        <div class="service-header">
                            <div style="flex: 1;">
                                <h3 class="service-title">${service.name}</h3>
                                ${service.description ? `<p class="service-description">${service.description}</p>` : ''}
                                <div class="service-meta">
                                    ${service.category ? `<span>üìÅ ${service.category}</span>` : ''}
                                    <span>üîç ${serviceMonitors.length} monitor${serviceMonitors.length !== 1 ? 's' : ''}</span>
                                </div>
                            </div>
                            <div class="service-actions">
                                <button class="icon-btn" onclick="showEditServiceModal(${service.id}, '${service.name.replace(/'/g, "\\'")}', '${(service.description || '').replace(/'/g, "\\'")}', '${(service.category || '').replace(/'/g, "\\'")}')">
                                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"></path></svg>
                                </button>
                                <button class="icon-btn delete" onclick="deleteService(${service.id})">
                                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                                </button>
                            </div>
                        </div>
                        ${serviceMonitors.length > 0 ? `
                            <div class="monitors-section">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                    <h4 class="monitors-title">Monitors</h4>
                                    <button class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="showAddMonitorToServiceModal(${service.id}, '${service.name.replace(/'/g, "\\'")}')">+ Add Monitor</button>
                                </div>
                                ${serviceMonitors.map(monitor => `
                                    <div class="monitor-item">
                                        <div class="monitor-info">
                                            <div class="monitor-type">${getMonitorTypeName(monitor.monitor_type)}${monitor.config && monitor.config.name ? ` [${monitor.config.name}]` : ''}</div>
                                            <div class="monitor-config">${getMonitorDescription(monitor)}</div>
                                            <div class="monitor-interval">Every ${monitor.check_interval_minutes} minutes</div>
                                        </div>
                                        <div class="monitor-actions">
                                            <button class="icon-btn" onclick="editMonitor(${monitor.id})">
                                                <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"></path></svg>
                                            </button>
                                            <button class="icon-btn delete" onclick="deleteMonitor(${monitor.id})">
                                                <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : `
                            <div class="monitors-section">
                                <p style="color: var(--text-tertiary); text-align: center; padding: 1rem;">No monitors configured</p>
                                <button class="btn btn-secondary" style="width: 100%;" onclick="showAddMonitorToServiceModal(${service.id}, '${service.name.replace(/'/g, "\\'")}')">+ Add First Monitor</button>
                            </div>
                        `}
                    </div>
                `;
                }).join('');
            } catch (error) {
                console.error('Failed to load services:', error);
            }
        }

        function getMonitorTypeName(type) {
            const iconMap = {
                'website': icons.globe,
                'api': icons.api,
                'metric_threshold': icons.chart,
                'port': icons.port,
                'deadman': icons.skull,
                'ssl_cert': icons.shield
            };
            const nameMap = {
                'website': 'Website',
                'api': 'API',
                'metric_threshold': 'Metric',
                'port': 'Port',
                'deadman': 'Deadman',
                'ssl_cert': 'SSL Certificate'
            };
            const icon = iconMap[type] || '';
            const name = nameMap[type] || type;
            return `<span class="monitor-type-badge"><span class="icon" style="width: 14px; height: 14px;">${icon}</span>${name}</span>`;
        }

        function getMonitorDescription(monitor) {
            if (!monitor.config) return '';
            const c = monitor.config;
            if (monitor.monitor_type === 'website') return c.url;
            if (monitor.monitor_type === 'api') return `${c.method || 'GET'} ${c.url}`;
            if (monitor.monitor_type === 'metric_threshold') return `Warning ${c.comparison === 'greater' ? '>' : '<'} ${c.warning_threshold}, Critical ${c.comparison === 'greater' ? '>' : '<'} ${c.critical_threshold}`;
            if (monitor.monitor_type === 'port') return `${c.host}:${c.port}`;
            if (monitor.monitor_type === 'deadman') return `Expect every ${c.expected_interval_hours}h (grace: ${c.grace_period_hours}h)`;
            if (monitor.monitor_type === 'ssl_cert') return `${c.hostname}:${c.port} (Warn: ${c.warning_days}d, Critical: ${c.critical_days}d)`;
            return '';
        }

        // Modal functions
        // Initialize collapsible triggers (for dynamically generated content)
        function initializeCollapsibles() {
            document.querySelectorAll('.collapsible-trigger').forEach(trigger => {
                // Remove any existing listeners
                const newTrigger = trigger.cloneNode(true);
                trigger.parentNode.replaceChild(newTrigger, trigger);

                newTrigger.addEventListener('click', function() {
                    const isExpanded = this.getAttribute('aria-expanded') === 'true';
                    this.setAttribute('aria-expanded', !isExpanded);

                    const content = this.parentElement.querySelector('.collapsible-content');
                    if (content) {
                        content.classList.toggle('expanded');
                    }
                });
            });
        }

        function showAddServiceModal() { document.getElementById('addServiceModal').classList.remove('hidden'); }
        function hideAddServiceModal() { document.getElementById('addServiceModal').classList.add('hidden'); }
        function showQuickMonitorModal() { document.getElementById('quickMonitorModal').classList.remove('hidden'); }
        function hideQuickMonitorModal() {
            document.getElementById('quickMonitorModal').classList.add('hidden');
            backToMonitorSelection();
        }
        async function showEditServiceModal(id, name, desc, cat) {
            document.getElementById('editServiceId').value = id;
            document.getElementById('editServiceName').value = name;
            document.getElementById('editServiceDescription').value = desc;
            document.getElementById('editServiceCategory').value = cat;

            // Load notification settings for this service
            await loadNotificationSettingsForService(id);

            document.getElementById('editServiceModal').classList.remove('hidden');
        }
        function hideEditServiceModal() { document.getElementById('editServiceModal').classList.add('hidden'); }

        // Plugin-based monitor type selection
        function selectMonitorType(type) {
            currentQuickMonitorType = type;
            const monitor = monitorRegistry.get(type);
            if (!monitor) {
                showError('Monitor type not found: ' + type);
                return;
            }

            // Hide type selection, show form
            document.getElementById('monitorTypeSelection').classList.add('hidden');
            document.getElementById('monitorConfigForm').classList.remove('hidden');

            // Update form title
            document.getElementById('monitorFormTitle').textContent = monitor.name + ' Configuration';

            // Generate form fields using registry
            const serviceName = ''; // Will be extracted from form on submit
            const formHTML = monitorRegistry.renderForm(monitor, type, true) +
                            monitorRegistry.renderIntervalDropdown(monitor, type) +
                            monitorRegistry.renderCollapsible(monitor, type, serviceName || 'SERVICE_NAME');

            document.getElementById('quickMonitorFormFields').innerHTML = formHTML;

            // Initialize collapsible triggers
            initializeCollapsibles();
        }

        function backToMonitorSelection() {
            document.getElementById('monitorConfigForm').classList.add('hidden');
            document.getElementById('monitorTypeSelection').classList.remove('hidden');
            currentQuickMonitorType = null;
        }

        // Form submissions
        document.getElementById('addServiceForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            try {
                await api.createService({
                    name: document.getElementById('serviceName').value,
                    description: document.getElementById('serviceDescription').value,
                    category: document.getElementById('serviceCategory').value
                });
                hideAddServiceModal();
                e.target.reset();
                loadServices();
                showSuccess('Service created successfully');
            } catch (error) {
                showError('Failed to create service: ' + error.message);
            }
        });

        document.getElementById('editServiceForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            try {
                const id = document.getElementById('editServiceId').value;

                // Update service details
                await api.updateService(id, {
                    name: document.getElementById('editServiceName').value,
                    description: document.getElementById('editServiceDescription').value,
                    category: document.getElementById('editServiceCategory').value
                });

                // Update notification settings
                const channelCheckboxes = document.querySelectorAll('input[name="webhook_channel"]:checked');
                const selectedChannelIds = Array.from(channelCheckboxes).map(cb => cb.value);

                await authenticatedFetch(`/api/v1/notifications/services/${id}`, {
                    method: 'PUT',
                    body: JSON.stringify({
                        enabled: document.getElementById('editNotificationsEnabled').checked,
                        email_enabled: document.getElementById('editEmailEnabled').checked,
                        email_recipients: document.getElementById('editEmailRecipients').value || null,
                        channel_ids: selectedChannelIds.length > 0 ? JSON.stringify(selectedChannelIds.map(Number)) : null,
                        cooldown_minutes: parseInt(document.getElementById('editCooldownMinutes').value),
                        notify_on_recovery: document.getElementById('editNotifyOnRecovery').checked
                    })
                });

                hideEditServiceModal();
                loadServices();
                showSuccess('Service updated successfully');
            } catch (error) {
                showError('Failed to update service: ' + error.message);
            }
        });

        // Generic Quick Monitor submit handler (replaces all 6 createXXXMonitor functions)
        async function handleQuickMonitorSubmit(event) {
            event.preventDefault();

            if (!currentQuickMonitorType) {
                showError('No monitor type selected');
                return;
            }

            const monitor = monitorRegistry.get(currentQuickMonitorType);
            if (!monitor) {
                showError('Monitor not found: ' + currentQuickMonitorType);
                return;
            }

            try {
                // Extract configuration using plugin's extractConfig method
                const config = monitor.extractConfig(currentQuickMonitorType);

                // Validate using plugin's validate method
                const validationError = monitor.validate(config);
                if (validationError) {
                    showError('Validation error: ' + validationError);
                    return;
                }

                // Get service name and interval
                const serviceName = document.getElementById(`${currentQuickMonitorType}ServiceName`).value;
                const interval = parseInt(document.getElementById(`${currentQuickMonitorType}Interval`).value);

                // Create service
                const service = await api.createService({
                    name: serviceName,
                    description: monitor.name,
                    category: 'Monitor'
                });

                // Create monitor
                await api.createMonitor({
                    service_id: service.id,
                    monitor_type: currentQuickMonitorType,
                    config: config,
                    check_interval_minutes: interval
                });

                hideQuickMonitorModal();
                loadServices();

                // Show success with endpoint info for metric_threshold and deadman monitors
                if (currentQuickMonitorType === 'metric_threshold' && config.name) {
                    const encodedService = encodeURIComponent(serviceName);
                    const encodedMonitor = encodeURIComponent(config.name);
                    const endpoint = `/api/v1/metric/${encodedService}/${encodedMonitor}`;
                    showSuccess(`Monitor created successfully! Send values to: POST ${endpoint}`);
                } else if (currentQuickMonitorType === 'deadman' && config.name) {
                    const encodedService = encodeURIComponent(serviceName);
                    const encodedMonitor = encodeURIComponent(config.name);
                    const endpoint = `/api/v1/heartbeat/${encodedService}/${encodedMonitor}`;
                    showSuccess(`Monitor created successfully! Send heartbeats to: POST ${endpoint}`);
                } else {
                    showSuccess('Monitor created successfully');
                }
            } catch (error) {
                showError('Failed to create monitor: ' + error.message);
            }
        }

        async function deleteService(id) {
            const confirmed = await showConfirm(
                'Are you sure you want to delete this service and all its monitors?',
                {
                    title: 'Delete Service',
                    confirmText: 'Delete',
                    cancelText: 'Cancel',
                    confirmClass: 'btn-danger'
                }
            );
            if (!confirmed) return;
            try {
                await api.deleteService(id);
                loadServices();
                showSuccess('Service deleted successfully');
            } catch (error) {
                showError('Failed to delete service: ' + error.message);
            }
        }

        async function deleteMonitor(id) {
            const confirmed = await showConfirm(
                'Are you sure you want to delete this monitor?',
                {
                    title: 'Delete Monitor',
                    confirmText: 'Delete',
                    cancelText: 'Cancel',
                    confirmClass: 'btn-danger'
                }
            );
            if (!confirmed) return;
            try {
                await api.deleteMonitor(id);
                loadServices();
                showSuccess('Monitor deleted successfully');
            } catch (error) {
                showError('Failed to delete monitor: ' + error.message);
            }
        }

        // Add Monitor to Existing Service functions
        function showAddMonitorToServiceModal(serviceId, serviceName) {
            document.getElementById('targetServiceId').value = serviceId;
            document.getElementById('targetServiceName').textContent = serviceName;

            // Generate type selection cards using registry
            document.getElementById('addMonitorTypeGrid').innerHTML = monitorRegistry.renderTypeCards('selectAddMonitorType');

            document.getElementById('addMonitorToServiceModal').classList.remove('hidden');
        }

        function hideAddMonitorToServiceModal() {
            document.getElementById('addMonitorToServiceModal').classList.add('hidden');
            backToAddMonitorSelection();
        }

        let currentAddMonitorType = null;

        function selectAddMonitorType(type) {
            currentAddMonitorType = type;
            const monitor = monitorRegistry.get(type);
            if (!monitor) {
                showError('Monitor type not found: ' + type);
                return;
            }

            // Hide type selection, show form
            document.getElementById('addMonitorTypeSelection').classList.add('hidden');
            document.getElementById('addMonitorConfigForm').classList.remove('hidden');

            // Update form title
            document.getElementById('addMonitorFormTitle').textContent = monitor.name + ' Configuration';

            // Generate form fields using registry
            const serviceName = document.getElementById('targetServiceName').textContent;
            const formPrefix = 'addMonitor';
            const formHTML = monitorRegistry.renderForm(monitor, formPrefix, false) +
                            monitorRegistry.renderIntervalDropdown(monitor, formPrefix) +
                            monitorRegistry.renderCollapsible(monitor, formPrefix, serviceName);

            document.getElementById('addMonitorFormFields').innerHTML = formHTML;

            // Initialize collapsible triggers
            initializeCollapsibles();
        }

        function backToAddMonitorSelection() {
            document.getElementById('addMonitorConfigForm').classList.add('hidden');
            document.getElementById('addMonitorTypeSelection').classList.remove('hidden');
            currentAddMonitorType = null;
        }

        // Generic Add Monitor submit handler (replaces all 6 addXXXMonitorToService functions)
        async function handleAddMonitorSubmit(event) {
            event.preventDefault();

            if (!currentAddMonitorType) {
                showError('No monitor type selected');
                return;
            }

            const monitor = monitorRegistry.get(currentAddMonitorType);
            if (!monitor) {
                showError('Monitor not found: ' + currentAddMonitorType);
                return;
            }

            try {
                // Extract configuration using plugin's extractConfig method
                const config = monitor.extractConfig('addMonitor');

                // Validate using plugin's validate method
                const validationError = monitor.validate(config);
                if (validationError) {
                    showError('Validation error: ' + validationError);
                    return;
                }

                // Get service ID and interval
                const serviceId = parseInt(document.getElementById('targetServiceId').value);
                const serviceName = document.getElementById('targetServiceName').textContent;
                const interval = parseInt(document.getElementById('addMonitorInterval').value);

                // Create monitor
                await api.createMonitor({
                    service_id: serviceId,
                    monitor_type: currentAddMonitorType,
                    config: config,
                    check_interval_minutes: interval
                });

                hideAddMonitorToServiceModal();
                loadServices();

                // Show success with endpoint info for metric_threshold and deadman monitors
                if (currentAddMonitorType === 'metric_threshold' && config.name) {
                    const encodedService = encodeURIComponent(serviceName);
                    const encodedMonitor = encodeURIComponent(config.name);
                    const endpoint = `/api/v1/metric/${encodedService}/${encodedMonitor}`;
                    showSuccess(`Monitor added successfully! Send values to: POST ${endpoint}`);
                } else if (currentAddMonitorType === 'deadman' && config.name) {
                    const encodedService = encodeURIComponent(serviceName);
                    const encodedMonitor = encodeURIComponent(config.name);
                    const endpoint = `/api/v1/heartbeat/${encodedService}/${encodedMonitor}`;
                    showSuccess(`Monitor added successfully! Send heartbeats to: POST ${endpoint}`);
                } else {
                    showSuccess('Monitor added successfully');
                }
            } catch (error) {
                showError('Failed to add monitor: ' + error.message);
            }
        }

        // Generic Edit Monitor function (replaces all 6 type-specific functions)
        async function editMonitor(monitorId) {
            try {
                const monitor = await api.getMonitor(monitorId);
                const monitorPlugin = monitorRegistry.get(monitor.monitor_type);

                if (!monitorPlugin) {
                    showError('Monitor type not found: ' + monitor.monitor_type);
                    return;
                }

                // Fetch service for metric and deadman monitors (needed for API endpoint preview)
                let serviceName = '';
                if (monitor.monitor_type === 'metric_threshold' || monitor.monitor_type === 'deadman') {
                    const service = await api.getService(monitor.service_id);
                    serviceName = service.name;
                }

                // Store monitor info in hidden fields
                document.getElementById('editMonitorId').value = monitor.id;
                document.getElementById('editMonitorType').value = monitor.monitor_type;
                document.getElementById('editMonitorServiceId').value = monitor.service_id;
                document.getElementById('editMonitorServiceName').value = serviceName;

                // Update modal title
                document.getElementById('editMonitorTitle').textContent = `Edit ${monitorPlugin.name}`;

                // Generate form fields using registry and populate with existing values
                const formPrefix = 'editMonitor';
                const formHTML = monitorRegistry.renderForm(monitorPlugin, formPrefix, false) +
                                monitorRegistry.renderIntervalDropdown(monitorPlugin, formPrefix) +
                                monitorRegistry.renderCollapsible(monitorPlugin, formPrefix, serviceName);

                document.getElementById('editMonitorFormFields').innerHTML = formHTML;

                // Populate form with existing monitor values
                monitorPlugin.populateForm(formPrefix, monitor.config);
                document.getElementById('editMonitorInterval').value = monitor.check_interval_minutes;

                // Initialize collapsible triggers
                initializeCollapsibles();

                // Show modal
                document.getElementById('editMonitorModal').classList.remove('hidden');
            } catch (error) {
                showError('Failed to load monitor: ' + error.message);
            }
        }

        function hideEditMonitorModal() {
            document.getElementById('editMonitorModal').classList.add('hidden');
        }

        // Generic Edit Monitor submit handler
        async function handleEditMonitorSubmit(event) {
            event.preventDefault();

            const monitorId = document.getElementById('editMonitorId').value;
            const monitorType = document.getElementById('editMonitorType').value;

            const monitorPlugin = monitorRegistry.get(monitorType);
            if (!monitorPlugin) {
                showError('Monitor type not found: ' + monitorType);
                return;
            }

            try {
                // Extract configuration using plugin's extractConfig method
                const config = monitorPlugin.extractConfig('editMonitor');

                // Validate using plugin's validate method
                const validationError = monitorPlugin.validate(config);
                if (validationError) {
                    showError('Validation error: ' + validationError);
                    return;
                }

                // Get interval
                const interval = parseInt(document.getElementById('editMonitorInterval').value);

                // Update monitor
                await api.updateMonitor(monitorId, {
                    config: config,
                    check_interval_minutes: interval
                });

                hideEditMonitorModal();
                loadServices();
                showSuccess('Monitor updated successfully');
            } catch (error) {
                showError('Failed to update monitor: ' + error.message);
            }
        }

        // Close modals on background click
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            });
        });

        // ============================================
        // Notification Settings Functions
        // ============================================

        // Toggle email recipients field visibility
        document.getElementById('editEmailEnabled').addEventListener('change', (e) => {
            const recipientsGroup = document.getElementById('emailRecipientsGroup');
            if (e.target.checked) {
                recipientsGroup.style.display = 'block';
            } else {
                recipientsGroup.style.display = 'none';
            }
        });

        // Toggle notification settings content visibility
        document.getElementById('editNotificationsEnabled').addEventListener('change', (e) => {
            const content = document.getElementById('notificationSettingsContent');
            if (e.target.checked) {
                content.style.opacity = '1';
                content.style.pointerEvents = 'auto';
            } else {
                content.style.opacity = '0.5';
                content.style.pointerEvents = 'none';
            }
        });

        async function loadNotificationSettingsForService(serviceId) {
            try {
                // Load all active webhook channels (tested or not)
                const channelsResponse = await authenticatedFetch('/api/v1/notifications/channels');
                const activeChannels = (channelsResponse.channels || []).filter(c => c.is_active);

                // Render webhook channels checkboxes
                const webhookList = document.getElementById('webhookChannelsList');
                if (activeChannels.length === 0) {
                    webhookList.innerHTML = '<span style="color: var(--text-tertiary);">No webhook channels configured. <a href="/static/notifications.html" style="color: var(--accent-primary);">Add channels</a></span>';
                } else {
                    webhookList.innerHTML = activeChannels.map(channel => `
                        <label class="checkbox-label" style="margin-bottom: 0.5rem;">
                            <input type="checkbox" name="webhook_channel" value="${channel.id}" class="form-checkbox">
                            <span>${channel.label} (${channel.channel_type})${channel.is_tested ? ' ' : ' (not tested)'}</span>
                        </label>
                    `).join('');
                }

                // Load existing notification settings (API returns settings object directly)
                const settings = await authenticatedFetch(`/api/v1/notifications/services/${serviceId}`);
                if (settings && settings.service_id) {

                    document.getElementById('editNotificationsEnabled').checked = settings.enabled;
                    document.getElementById('editEmailEnabled').checked = settings.email_enabled;
                    document.getElementById('editEmailRecipients').value = settings.email_recipients || '';
                    document.getElementById('editCooldownMinutes').value = settings.cooldown_minutes;
                    document.getElementById('editNotifyOnRecovery').checked = settings.notify_on_recovery;

                    // Show/hide email recipients group
                    document.getElementById('emailRecipientsGroup').style.display = settings.email_enabled ? 'block' : 'none';

                    // Check selected channels
                    if (settings.channel_ids) {
                        try {
                            const selectedIds = JSON.parse(settings.channel_ids);
                            selectedIds.forEach(id => {
                                const checkbox = document.querySelector(`input[name="webhook_channel"][value="${id}"]`);
                                if (checkbox) checkbox.checked = true;
                            });
                        } catch (e) {
                            console.error('Failed to parse channel_ids:', e);
                        }
                    }

                    // Update content visibility
                    const content = document.getElementById('notificationSettingsContent');
                    if (settings.enabled) {
                        content.style.opacity = '1';
                        content.style.pointerEvents = 'auto';
                    } else {
                        content.style.opacity = '0.5';
                        content.style.pointerEvents = 'none';
                    }
                } else {
                    // No settings exist, use defaults
                    document.getElementById('editNotificationsEnabled').checked = true;
                    document.getElementById('editEmailEnabled').checked = false;
                    document.getElementById('editEmailRecipients').value = '';
                    document.getElementById('editCooldownMinutes').value = 5;
                    document.getElementById('editNotifyOnRecovery').checked = true;
                    document.getElementById('emailRecipientsGroup').style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to load notification settings:', error);
                // Use defaults on error
                document.getElementById('webhookChannelsList').innerHTML = '<span style="color: var(--text-tertiary);">Failed to load channels</span>';
            }
        }

        loadServices();
    </script>
</body>
</html>
